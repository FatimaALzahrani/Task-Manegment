{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport { defineStore } from 'pinia';\nimport { dataService } from '@/services/firebase';\nexport const useDataStore = defineStore({\n  id: 'data',\n  state: () => ({\n    children: [],\n    wordData: {},\n    words: [],\n    loading: false,\n    error: null,\n    selectedChild: null,\n    averageDuration: 3.5 // Default value\n  }),\n  getters: {\n    completionPercentage: state => {\n      if (state.children.length === 0 || state.words.length === 0) return 0;\n      let totalWords = state.children.length * state.words.length;\n      let completedWords = 0;\n      state.children.forEach(child => {\n        state.words.forEach(word => {\n          if (state.wordData[child.id] && state.wordData[child.id][word] && state.wordData[child.id][word].done) {\n            completedWords++;\n          }\n        });\n      });\n      return Math.round(completedWords / totalWords * 100);\n    }\n  },\n  actions: {\n    async fetchChildren() {\n      this.loading = true;\n      this.error = null;\n      try {\n        dataService.getChildren(children => {\n          this.children = children;\n          this.loading = false;\n        });\n      } catch (error) {\n        this.error = error.message;\n        this.loading = false;\n      }\n    },\n    async fetchWordData() {\n      this.loading = true;\n      this.error = null;\n      try {\n        dataService.getWordData(data => {\n          this.wordData = data;\n\n          // Extract unique words\n          const allWords = new Set();\n          Object.values(data).forEach(childWords => {\n            Object.keys(childWords).forEach(word => {\n              allWords.add(word);\n            });\n          });\n          this.words = Array.from(allWords);\n          this.loading = false;\n        });\n      } catch (error) {\n        this.error = error.message;\n        this.loading = false;\n      }\n    },\n    async saveChild(childId, childData) {\n      this.loading = true;\n      this.error = null;\n      try {\n        await dataService.saveChild(childId, childData);\n        this.loading = false;\n      } catch (error) {\n        this.error = error.message;\n        this.loading = false;\n      }\n    },\n    async deleteChild(childId) {\n      this.loading = true;\n      this.error = null;\n      try {\n        await dataService.deleteChild(childId);\n        this.loading = false;\n      } catch (error) {\n        this.error = error.message;\n        this.loading = false;\n      }\n    },\n    async addWord(word) {\n      this.loading = true;\n      this.error = null;\n      try {\n        await dataService.addWord(word, this.children);\n        this.loading = false;\n      } catch (error) {\n        this.error = error.message;\n        this.loading = false;\n      }\n    },\n    async updateWordData(childId, word, data) {\n      this.error = null;\n      try {\n        await dataService.updateWordData(childId, word, data);\n      } catch (error) {\n        this.error = error.message;\n      }\n    },\n    getWordLevel(childId, word) {\n      if (!this.wordData[childId] || !this.wordData[childId][word]) return 'ضعيف';\n      return this.wordData[childId][word].level || 'ضعيف';\n    },\n    isWordDone(childId, word) {\n      if (!this.wordData[childId] || !this.wordData[childId][word]) return false;\n      return this.wordData[childId][word].done || false;\n    },\n    setSelectedChild(child) {\n      this.selectedChild = child ? {\n        ...child\n      } : null;\n    }\n  }\n});","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}